{
  "hash": "25c17e6b5f90dc41418fe8e60f5e0324",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Using character values in dplyr functions.\"\nauthor: \"MJH\"\ndate: \"2024-09-20\"\ncategories: [\"Data Science/Programming\"]\n---\n\n\n\n\n\n\n\n\nIn the book [R for Data Science (2e)](https://r4ds.hadley.nz/) there is a section titled [25.3.1 Indirection and tidy evaluation](https://r4ds.hadley.nz/functions#indirection-and-tidy-evaluation) which discusses how to use dplyr code inside of functions.  They do a really good job of outlining how to utilize embracing `{{}}` so your variables properly resolve, but there does not seem to be any space dedicated on how to incorporate character variables generated via `paste0()`,`paste()`,`str_glue()`,`glue::glue()`, etc... into these dplyr functions. For me, this problem typically arises when I'm trying to nest a function inside a loop that utilizes `paste()` or `str_glue()` to dynamically generate the variable names I need to call in the function.       \n\n\n\nLets load the libraries we'll use.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n\n\nNext, lets create a simple data set we'll use for our examples.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(8675309)\n\ndf <- tibble(\n  group1 = c(rep(\"A\",10),rep(\"B\",10)),\n  group2 = rep(  c(rep(\"C\",5),rep(\"D\",5))   ,2),\n  group3 = rep(  c(rep(\"E\",2),rep(\"F\",3))   ,4),\n  value = round(rnorm(20,100,15))\n)\nglimpse(df)\n## Rows: 20\n## Columns: 4\n## $ group1 <chr> \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"A\", \"B\", \"B\", \"B\"…\n## $ group2 <chr> \"C\", \"C\", \"C\", \"C\", \"C\", \"D\", \"D\", \"D\", \"D\", \"D\", \"C\", \"C\", \"C\"…\n## $ group3 <chr> \"E\", \"E\", \"F\", \"F\", \"F\", \"E\", \"E\", \"F\", \"F\", \"F\", \"E\", \"E\", \"F\"…\n## $ value  <dbl> 85, 111, 91, 130, 116, 115, 100, 110, 109, 114, 77, 115, 102, 9…\n```\n:::\n\n\n\n\nSome simple dplyr code, we'll turn the second output into a function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\ndf |>\n  summarize(mean = mean(value)) \n## # A tibble: 1 × 1\n##    mean\n##   <dbl>\n## 1  102.\n\ndf |>\n  group_by(group1, group2, group3) |>\n  summarize(mean = mean(value)) %>%\n  ungroup()\n## # A tibble: 8 × 4\n##   group1 group2 group3  mean\n##   <chr>  <chr>  <chr>  <dbl>\n## 1 A      C      E       98  \n## 2 A      C      F      112. \n## 3 A      D      E      108. \n## 4 A      D      F      111  \n## 5 B      C      E       96  \n## 6 B      C      F       92.3\n## 7 B      D      E      112. \n## 8 B      D      F       90.7\n```\n:::\n\n\n\n\n\nLets say we're ready to create a function to wrap around this dplyr code.  This is where [embracing ({{}})](https://r4ds.hadley.nz/functions#sec-embracing) comes into the picture.  Any variable we want to evaluate in the function needs to be embraced, otherwise it will not evaluate correctly.  As a side note, using `across()` in the `group_by()` allows us to use multiple variables in our group_vars input.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfunction1 <- function(input_data, summary_variable, group_vars=NULL){\n  input_data |>\n  group_by(across({{group_vars}})) |>\n  summarize(mean_calc = mean({{summary_variable}})) %>%\n  ungroup()\n}\n\nfunction1(input_data = df, summary_variable = value)\n## # A tibble: 1 × 1\n##   mean_calc\n##       <dbl>\n## 1      102.\nfunction1(input_data = df, summary_variable = value, group_vars = group1)\n## # A tibble: 2 × 2\n##   group1 mean_calc\n##   <chr>      <dbl>\n## 1 A          108. \n## 2 B           96.4\nfunction1(input_data = df, summary_variable = value, group_vars = c(group1,group2))\n## # A tibble: 4 × 3\n##   group1 group2 mean_calc\n##   <chr>  <chr>      <dbl>\n## 1 A      C          107. \n## 2 A      D          110. \n## 3 B      C           93.8\n## 4 B      D           99\n```\n:::\n\n\n\n\n\nSo this is fine, and typically works great, but if you ever run into an instance where you're trying to pass a character string as a variable name it's going to be a problem.  For these examples we'll just use character strings to mimic the output of `paste()` or `str_glue()` to keep things a bit easier to read.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_string <- \"value\"\n\nfunction1(input_data = df, summary_variable = sum_string)\n## Warning: There was 1 warning in `summarize()`.\n## ℹ In argument: `mean_calc = mean(sum_string)`.\n## Caused by warning in `mean.default()`:\n## ! argument is not numeric or logical: returning NA\n## # A tibble: 1 × 1\n##   mean_calc\n##       <dbl>\n## 1        NA\n```\n:::\n\n\n\n\n\n\nSo you get an error, and there are a few ways that you can work around this using `get()` and `str2lang()`/`do.call()` but it sometimes gets overly complex and is inconsistent for our example here. In the end we'll use a combination of `!!` and `sym()` which offers concise and consistent syntax with the ability to carry multiple variables into our `group_by()`.  Something that I was unable to get to working using the examples below. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nsum_string <- \"value\"\ngrp_string1 <- \"group1\"\n\n#works\nfunction1(\n  input_data = df, \n  summary_variable = get(sum_string),\n  group_vars = str2lang(grp_string1))\n## # A tibble: 2 × 2\n##   group1 mean_calc\n##   <chr>      <dbl>\n## 1 A          108. \n## 2 B           96.4\n\n#doesn't work\nfunction1(\n  input_data = df, \n  summary_variable = get(sum_string),\n  group_vars = get(grp_string1))\n## Error in `group_by()`:\n## ℹ In argument: `across(get(grp_string1))`.\n## Caused by error in `across()`:\n## ℹ In argument: `get(grp_string1)`.\n## Caused by error in `get()`:\n## ! object 'group1' not found\n\n#doesn't work\nfunction1(input_data = df, \n          summary_variable = str2lang(sum_string),\n          group_vars = str2lang(grp_string1))\n## Warning: There were 2 warnings in `summarize()`.\n## The first warning was:\n## ℹ In argument: `mean_calc = mean(str2lang(sum_string))`.\n## ℹ In group 1: `group1 = \"A\"`.\n## Caused by warning in `mean.default()`:\n## ! argument is not numeric or logical: returning NA\n## ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n## # A tibble: 2 × 2\n##   group1 mean_calc\n##   <chr>      <dbl>\n## 1 A             NA\n## 2 B             NA\n\n#works\ndo.call(\n  what = function1, \n  args = list(input_data = df, \n              summary_variable = str2lang(sum_string),\n              group_vars = str2lang(grp_string1))\n  )\n## # A tibble: 2 × 2\n##   group1 mean_calc\n##   <chr>      <dbl>\n## 1 A          108. \n## 2 B           96.4\n\n#doesn't work\ndo.call(\n  what = function1, \n  args = list(input_data = df, \n              summary_variable = get(sum_string),\n              group_vars = str2lang(grp_string1))\n  )\n## Error in get(sum_string): object 'value' not found\n```\n:::\n\n\n\n\n\nIn the end, we'll end up writing our function incorporating `!!` and `sym()` to make the call less verbose. Although if you are unable to modify the function you're trying to utilize, this might be your best course of action utilizing it in the function call.  `sym()` or `str2lang()` seem to behavior similar on the examples below and for this context seem to be interchangable.  \n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_string <- \"value\"\ngrp_string1 <- \"group1\"\ngrp_string2 <- \"group2\"\n\nfunction1(input_data = df, summary_variable = !!sym(sum_string))\n## # A tibble: 1 × 1\n##   mean_calc\n##       <dbl>\n## 1      102.\nfunction1(input_data = df, summary_variable = !!sym(sum_string), group_vars = !!sym(grp_string1))\n## # A tibble: 2 × 2\n##   group1 mean_calc\n##   <chr>      <dbl>\n## 1 A          108. \n## 2 B           96.4\nfunction1(input_data = df, summary_variable = !!sym(sum_string), group_vars = c(!!sym(grp_string1),!!sym(grp_string2)))\n## # A tibble: 4 × 3\n##   group1 group2 mean_calc\n##   <chr>  <chr>      <dbl>\n## 1 A      C          107. \n## 2 A      D          110. \n## 3 B      C           93.8\n## 4 B      D           99\n\n#sym() and str2lang() seem to behavior similar here.\nfunction1(input_data = df, summary_variable = !!str2lang(sum_string), group_vars = c(!!str2lang(grp_string1),!!str2lang(grp_string2)))\n## # A tibble: 4 × 3\n##   group1 group2 mean_calc\n##   <chr>  <chr>      <dbl>\n## 1 A      C          107. \n## 2 A      D          110. \n## 3 B      C           93.8\n## 4 B      D           99\n```\n:::\n\n\n\n\nIf you wanted to make your call a little neater, you could also wrap your character string in `sym()` or `str2lang()` outside of the call.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum_string <- sym(\"value\")\ngrp_string1 <- sym(\"group1\")\ngrp_string2 <- str2lang(\"group2\")\n\nfunction1(input_data = df, summary_variable = !!sum_string, group_vars = c(!!grp_string1,!!grp_string2))\n## # A tibble: 4 × 3\n##   group1 group2 mean_calc\n##   <chr>  <chr>      <dbl>\n## 1 A      C          107. \n## 2 A      D          110. \n## 3 B      C           93.8\n## 4 B      D           99\n```\n:::\n\n\n\n\n\n\n\nIn the end though, it still takes some work to make these calls and it's not a real great solution for the use case of throwing a function inside a loop and letting it fly.  Below would be what I would choose to use in the case I had control and the ability to write the function from scratch.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize_by_group <- function(input_data, summary_variable, group_vars = NULL) {\n  if(!is.null(group_vars)){\n    grp_squished <- str_replace_all(group_vars,\" \",\"\")\n    grp_split <- str_split(grp_squished, \",\")[[1]]\n    group_syms <- syms(grp_split)\n    }else{group_syms = NULL}\n  input_data |>\n    group_by(!!!group_syms) |>\n    summarize(mean = mean(!!sym(summary_variable)))\n}\n\nsum_string <- \"value\"\ngrp_string1 <- \"group1\"\ngrp_string2 <- \"group1,group2\"\n\nsummarize_by_group(input_data = df, summary_variable = sum_string)\n## # A tibble: 1 × 1\n##    mean\n##   <dbl>\n## 1  102.\nsummarize_by_group(input_data = df, summary_variable = sum_string, group_vars=grp_string1)\n## # A tibble: 2 × 2\n##   group1  mean\n##   <chr>  <dbl>\n## 1 A      108. \n## 2 B       96.4\nsummarize_by_group(input_data = df, summary_variable = sum_string, group_vars=grp_string2)\n## # A tibble: 4 × 3\n## # Groups:   group1 [2]\n##   group1 group2  mean\n##   <chr>  <chr>  <dbl>\n## 1 A      C      107. \n## 2 A      D      110. \n## 3 B      C       93.8\n## 4 B      D       99\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}